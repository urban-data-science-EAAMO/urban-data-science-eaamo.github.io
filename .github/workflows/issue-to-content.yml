name: Issue to Content

on:
  issues:
    types: [opened, edited, reopened, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

jobs:
  reading_list:
    if: github.event.repository.full_name == github.repository && (
      contains(github.event.issue.labels.*.name, 'reading-list') ||
      contains(github.event.issue.labels.*.name, 'publication') ||
      contains(github.event.issue.labels.*.name, 'publications') ||
      contains(github.event.issue.labels.*.name, 'paper') ||
      contains(github.event.issue.labels.*.name, 'papers')
    )
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract issue fields
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';
            function getField(id) {
              const re = new RegExp(`(?<=\n### ${id}\n)\\s*([^\n]+)`, 'i');
              const m = body.match(re); return m ? m[1].trim() : '';
            }
            const doi = getField('DOI');
            if (!doi) core.setFailed('DOI is required');
            const title = getField('Title (optional)');
            const authors = getField('Authors (optional)');
            const venue = getField('Venue (optional)');
            const year = getField('Year (optional)');
            const url = getField('URL (optional)');
            core.setOutput('doi', doi);
            core.setOutput('title', title);
            core.setOutput('authors', authors);
            core.setOutput('venue', venue);
            core.setOutput('year', year);
            core.setOutput('url', url);

      - name: Resolve DOI via Crossref
        id: crossref
        uses: actions/github-script@v7
        env:
          DOI: ${{ steps.parse.outputs.doi }}
        with:
          script: |
            const doi = process.env.DOI;
            try {
              const res = await fetch(`https://api.crossref.org/works/${encodeURIComponent(doi)}`, { headers: { 'Accept': 'application/json' } });
              if (!res.ok) {
                core.setOutput('ok', 'false');
                core.setOutput('status', String(res.status));
              } else {
                const data = await res.json();
                const item = data && data.message ? data.message : null;
                if (!item) {
                  core.setOutput('ok', 'false');
                  core.setOutput('status', 'no-message');
                } else {
                  const title = Array.isArray(item.title) ? (item.title[0] || doi) : (item.title || doi);
                  const authorsArr = Array.isArray(item.author) ? item.author : [];
                  const authors = authorsArr.map(a => [a?.given, a?.family].filter(Boolean).join(' ').trim()).filter(Boolean);
                  const authors_yaml = `[${authors.map(a => JSON.stringify(a)).join(', ')}]`;
                  const venue = (item['container-title'] && item['container-title'][0]) || item.publisher || '';
                  const year = (item.issued && item.issued['date-parts'] && item.issued['date-parts'][0] && item.issued['date-parts'][0][0]) || '';
                  const url = item.URL || (doi.startsWith('http') ? doi : `https://doi.org/${doi}`);
                  core.setOutput('ok', 'true');
                  core.setOutput('title', title);
                  core.setOutput('authors_yaml', authors_yaml);
                  core.setOutput('venue', venue);
                  core.setOutput('year', String(year));
                  core.setOutput('url', url);
                }
              }
            } catch (e) {
              core.setOutput('ok', 'false');
              core.setOutput('status', 'exception');
            }

      - name: Comment if DOI invalid
        if: steps.crossref.outputs.ok != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `❌ DOI could not be resolved (status: ${'${{ steps.crossref.outputs.status }}'}). Please check the DOI and resubmit.`
            });

      - name: Fail if DOI invalid
        if: steps.crossref.outputs.ok != 'true'
        run: exit 1

      - name: Check duplicate publication
        id: dup
        run: |
          slug=$(echo "${{ steps.parse.outputs.doi }}" | sed 's#[/:]#-#g' | tr -cd '[:alnum:]-._')
          file_path="src/content/publications/${slug}.md"
          if [ -f "$file_path" ]; then echo "exists=true" >> $GITHUB_OUTPUT; else echo "exists=false" >> $GITHUB_OUTPUT; fi

      - name: Comment duplicate and stop
        if: steps.dup.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ℹ️ This DOI already exists in the reading list. Skipping creation.`
            });
            core.info('Duplicate detected; stopping job.');

      - name: Create content file
        if: steps.dup.outputs.exists != 'true'
        run: |
          slug=$(echo "${{ steps.parse.outputs.doi }}" | sed 's#[/:]#-#g' | tr -cd '[:alnum:]-._')
          file_path="src/content/publications/${slug}.md"
          mkdir -p "$(dirname "$file_path")"

          esc() { printf "%s" "$1" | sed "s/'/''/g"; }

          DOI="${{ steps.parse.outputs.doi }}"
          P_TITLE="${{ steps.parse.outputs.title }}"; C_TITLE="${{ steps.crossref.outputs.title }}"
          P_AUTHORS="${{ steps.parse.outputs.authors }}"; C_AUTHORS_YAML="${{ steps.crossref.outputs.authors_yaml }}"
          P_VENUE="${{ steps.parse.outputs.venue }}"; C_VENUE="${{ steps.crossref.outputs.venue }}"
          P_YEAR="${{ steps.parse.outputs.year }}"; C_YEAR="${{ steps.crossref.outputs.year }}"
          P_URL="${{ steps.parse.outputs.url }}"; C_URL="${{ steps.crossref.outputs.url }}"

          echo "---" > "$file_path"
          echo "doi: '$(esc "$DOI")'" >> "$file_path"

          # Title from issue or Crossref (quoted)
          if [ -n "$P_TITLE" ]; then
            echo "title: '$(esc "$P_TITLE")'" >> "$file_path"
          elif [ -n "$C_TITLE" ]; then
            echo "title: '$(esc "$C_TITLE")'" >> "$file_path"
          fi

          # Authors from issue or Crossref
          if [ -n "$P_AUTHORS" ]; then
            authors_list=$(echo "$P_AUTHORS" | awk -F',' '{for(i=1;i<=NF;i++){gsub(/^ +| +$/, "", $i); gsub(/"/, "\\\"", $i); printf "%s\"%s\"", (i>1?", ":""), $i}}')
            echo "authors: [${authors_list}]" >> "$file_path"
          elif [ -n "$C_AUTHORS_YAML" ]; then
            echo "authors: $C_AUTHORS_YAML" >> "$file_path"
          fi

          # Venue from issue or Crossref (quoted)
          if [ -n "$P_VENUE" ]; then
            echo "venue: '$(esc "$P_VENUE")'" >> "$file_path"
          elif [ -n "$C_VENUE" ]; then
            echo "venue: '$(esc "$C_VENUE")'" >> "$file_path"
          fi

          # Year from issue or Crossref (numeric only)
          if echo "$P_YEAR" | grep -Eq '^[0-9]{4}$'; then
            echo "year: $P_YEAR" >> "$file_path"
          elif echo "$C_YEAR" | grep -Eq '^[0-9]{4}$'; then
            echo "year: $C_YEAR" >> "$file_path"
          fi

          # URL from issue or Crossref (quoted)
          if [ -n "$P_URL" ]; then
            echo "url: '$(esc "$P_URL")'" >> "$file_path"
          elif [ -n "$C_URL" ]; then
            echo "url: '$(esc "$C_URL")'" >> "$file_path"
          fi

          echo "tags: [publication]" >> "$file_path"
          echo "---" >> "$file_path"

      - name: Create Pull Request
        if: steps.dup.outputs.exists != 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v7
        with:
          commit-message: |
            chore(content): add reading list entry from issue #${{ github.event.issue.number }}

            Generated by automation.
          title: "Add reading list entry: #${{ github.event.issue.number }}"
          body: |
            This PR adds a reading list entry.

            Closes #${{ github.event.issue.number }}

            - DOI: ${{ steps.parse.outputs.doi }}
          branch: ci/add-reading-${{ github.event.issue.number }}
          labels: content, automated pr
          sign-commits: true

      - name: Auto-merge PR (reading list)
        if: steps.cpr.outputs.pull-request-number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = Number('${{ steps.cpr.outputs.pull-request-number }}');
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: number, merge_method: 'squash' });
              core.info(`Merged PR #${number}`);
            } catch (e) {
              core.info(`Auto-merge failed for PR #${number}: ${e.message}`);
            }

      - name: Trigger deploy workflow
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = context.payload?.repository?.default_branch || 'main';
            try {
              await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'deploy.yml', ref });
              core.info('Triggered deploy.yml');
            } catch (e) {
              core.info(`Failed to dispatch deploy.yml: ${e.message}`);
            }

      - name: Close originating issue
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed'
              });
            } catch (e) {
              core.info(`Failed to close issue: ${e.message}`);
            }

  member:
    if: github.event.repository.full_name == github.repository && (
      contains(github.event.issue.labels.*.name, 'member') ||
      contains(github.event.issue.labels.*.name, 'members')
    )
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure 'member' label (if issue looks like member form)
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            if (!issue || issue.state !== 'open') return;
            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const body = issue.body || '';
            const looksLikeForm = /Full name/i.test(body) && /(Image URL|repo path|image\s*:)/i.test(body);
            if (!labels.includes('member') && looksLikeForm) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['member']
              });
            }

      - name: Parse issue form
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';

            // Try to parse a fenced YAML block first (most robust)
            let yamlBlock;
            {
              const m = body.match(/```yaml[\s\S]*?```/i);
              if (m) {
                yamlBlock = m[0].replace(/```yaml/i, '').replace(/```\s*$/i, '').trim();
              }
            }
            const data = {};
            if (yamlBlock) {
              const lines = yamlBlock.split(/\r?\n/);
              for (const line of lines) {
                const mm = line.match(/^\s*([A-Za-z0-9_]+)\s*:\s*"?(.*?)"?\s*$/);
                if (mm) data[mm[1].toLowerCase()] = mm[2];
              }
            }

            // Helper to build a map of headings → content
            const headingMap = {};
            if (!data.name || !data.image) {
              const lines = body.split(/\r?\n/);
              let current = null; let buf = [];
              const flush = () => { if (current) { headingMap[current.toLowerCase()] = buf.join('\n').trim(); buf = []; } };
              for (const line of lines) {
                const h = line.match(/^\s*#{1,6}\s*(.*?)\s*$/);
                if (h) { flush(); current = h[1]; continue; }
                if (current) buf.push(line);
              }
              flush();
            }

            const fromHeadings = (needles) => {
              for (const [k, v] of Object.entries(headingMap)) {
                const lower = k.toLowerCase();
                if (needles.some(n => lower.includes(n))) return (v || '').trim();
              }
              return '';
            };
            const extractInline = (key) => {
              const m = body.match(new RegExp(`(^|\\r?\\n)\\s*${key}\\s*:\\s*(.+)`, 'i'));
              return m ? m[2].trim() : '';
            };

            const lower = (s) => (s || '').toLowerCase();
            let name = data.name || fromHeadings(['full name','name']) || extractInline('name');
            let role = data.role || fromHeadings(['role']) || extractInline('role');
            let affiliation = data.affiliation || fromHeadings(['affiliation']) || extractInline('affiliation');
            let image = data.image || fromHeadings(['image url','image','repo path']) || extractInline('image');
            let website = data.website || fromHeadings(['website','profile']) || extractInline('website');
            let order = data.order || fromHeadings(['order','ordering']) || extractInline('order');
            let tags = Array.isArray(data.tags) ? data.tags.join(', ') : (data.tags || fromHeadings(['tags']) || extractInline('tags'));

            if (!name && context.payload.issue.title) {
              const mt = context.payload.issue.title.match(/Add:\s*(.+)$/i);
              if (mt) name = mt[1].trim();
            }

            const invalids = new Set(['', '_no response_', 'n/a', 'na', 'none', 'null', 'remote url (link)']);
            const sanitizeWebsite = (u) => {
              const s = (u || '').trim();
              if (invalids.has(s.toLowerCase())) return 'https://example.com';
              try { new URL(s); return s; } catch { return 'https://example.com'; }
            };
            const sanitizeImage = (img) => {
              const s = (img || '').trim();
              if (invalids.has(s.toLowerCase())) return '../../assets/vista.jpg';
              if (/^https?:/i.test(s)) return s;
              if (/^(\.\.\/){1,2}?assets\//i.test(s) || /^src\//i.test(s)) return s;
              return '../../assets/vista.jpg';
            };
            const sanitizeOrder = (_) => 999;

            website = sanitizeWebsite(website);
            image = sanitizeImage(image);
            order = String(sanitizeOrder(order));

            if (!name) {
              core.info('Missing required field: name. Skipping.');
              core.setOutput('found', 'false');
              return;
            }
            const slugify = (s) => (s || '').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
            let slug = slugify(name);
            if (!slug) { slug = 'user-' + Date.now(); }

            core.setOutput('found', 'true');
            core.setOutput('name', name);
            core.setOutput('role', role || '');
            core.setOutput('affiliation', affiliation || '');
            core.setOutput('image', image);
            core.setOutput('website', website || '');
            core.setOutput('order', order || '999');
            core.setOutput('slug', slug);
            core.setOutput('tags', (tags || '').trim());

      - name: Ensure directories
        if: steps.parse.outputs.found == 'true'
        run: |
          mkdir -p src/content/members src/assets/members

      - name: Download image if URL
        id: dl
        if: steps.parse.outputs.found == 'true'
        run: |
          IMG="${{ steps.parse.outputs.image }}"
          if echo "$IMG" | grep -qi '^http'; then
            path=$(echo "$IMG" | sed -E 's|^[^:/]+://[^/]+||' | cut -d'?' -f1 | cut -d'#' -f1)
            filename=$(basename "$path")
            ext="${filename##*.}"
            if [ "$filename" = "$ext" ]; then ext="jpg"; fi
            out="src/assets/members/${{ steps.parse.outputs.slug }}.$ext"
            curl -L "$IMG" -o "$out"
            echo "path=../../assets/members/$(basename "$out")" >> $GITHUB_OUTPUT
          else
            echo "path=$IMG" >> $GITHUB_OUTPUT
          fi

      - name: Create content file
        if: steps.parse.outputs.found == 'true'
        run: |
          slug="${{ steps.parse.outputs.slug }}"
          file_path="src/content/members/${slug}.md"
          mkdir -p "$(dirname "$file_path")"
          IMAGE="${{ steps.dl.outputs.path }}"
          if [ -z "$IMAGE" ]; then IMAGE="${{ steps.parse.outputs.image }}"; fi
          echo "---" > "$file_path"
          echo "name: \"${{ steps.parse.outputs.name }}\"" >> "$file_path"
          echo "role: \"${{ steps.parse.outputs.role }}\"" >> "$file_path"
          echo "affiliation: \"${{ steps.parse.outputs.affiliation }}\"" >> "$file_path"
          echo "image: \"$IMAGE\"" >> "$file_path"
          echo "website: \"${{ steps.parse.outputs.website }}\"" >> "$file_path"
          echo "order: ${{ steps.parse.outputs.order }}" >> "$file_path"
          if [ -n "${{ steps.parse.outputs.tags }}" ]; then \
            tags_list=$(echo "${{ steps.parse.outputs.tags }}" | awk -F',' '{for(i=1;i<=NF;i++){gsub(/^ +| +$/, "", $i); printf "%s\"%s\"", (i>1?", ":""), $i}}'); \
            echo "tags: [${tags_list}]" >> "$file_path"; \
          else \
            echo 'tags: ["member"]' >> "$file_path"; \
          fi
          echo "---" >> "$file_path"

      - name: Create Pull Request
        id: cpr
        uses: peter-evans/create-pull-request@v7
        with:
          commit-message: |
            chore(content): add member entry from issue #${{ github.event.issue.number }}

            Generated by automation.
          title: "Add member: #${{ github.event.issue.number }}"
          body: |
            This PR adds a member entry.

            Closes #${{ github.event.issue.number }}

            - Name: ${{ steps.parse.outputs.name }}
          branch: ci/add-member-${{ github.event.issue.number }}
          labels: content, automated pr
          sign-commits: true

      - name: Auto-merge PR (member)
        if: steps.cpr.outputs.pull-request-number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = Number('${{ steps.cpr.outputs.pull-request-number }}');
            try {
              await github.rest.pulls.merge({ owner, repo, pull_number: number, merge_method: 'squash' });
              core.info(`Merged PR #${number}`);
            } catch (e) {
              core.info(`Auto-merge failed for PR #${number}: ${e.message}`);
            }

      - name: Trigger deploy workflow
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = context.payload?.repository?.default_branch || 'main';
            try {
              await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'deploy.yml', ref });
              core.info('Triggered deploy.yml');
            } catch (e) {
              core.info(`Failed to dispatch deploy.yml: ${e.message}`);
            }

      - name: Close originating issue
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed'
              });
            } catch (e) {
              core.info(`Failed to close issue: ${e.message}`);
            }


