name: "Issue → PR: Add Member"

on:
  issues:
    types: [opened, edited, reopened, labeled]

jobs:
  from-issue:
    runs-on: ubuntu-latest
    if: github.event.repository.full_name == github.repository
    permissions:
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure 'member' label (if issue looks like member form)
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            if (!issue || issue.state !== 'open') return;
            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const body = issue.body || '';
            const looksLikeForm = /Full name/i.test(body) && /(Image URL|repo path|image\s*:)/i.test(body);
            if (!labels.includes('member') && looksLikeForm) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['member']
              });
            }

      - name: Parse issue form
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';

            // Try to parse a fenced YAML block first (most robust)
            let yamlBlock;
            {
              const m = body.match(/```yaml[\s\S]*?```/i);
              if (m) {
                yamlBlock = m[0].replace(/```yaml/i, '').replace(/```\s*$/i, '').trim();
              }
            }
            const data = {};
            if (yamlBlock) {
              const lines = yamlBlock.split(/\r?\n/);
              for (const line of lines) {
                const mm = line.match(/^\s*([A-Za-z0-9_]+)\s*:\s*"?(.*?)"?\s*$/);
                if (mm) data[mm[1].toLowerCase()] = mm[2];
              }
            }

            // Helper to build a map of headings → content
            const headingMap = {};
            if (!data.name || !data.image) {
              const lines = body.split(/\r?\n/);
              let current = null; let buf = [];
              const flush = () => { if (current) { headingMap[current.toLowerCase()] = buf.join('\n').trim(); buf = []; } };
              for (const line of lines) {
                const h = line.match(/^\s*#{1,6}\s*(.*?)\s*$/);
                if (h) { flush(); current = h[1]; continue; }
                if (current) buf.push(line);
              }
              flush();
            }

            const fromHeadings = (needles) => {
              for (const [k, v] of Object.entries(headingMap)) {
                const lower = k.toLowerCase();
                if (needles.some(n => lower.includes(n))) return (v || '').trim();
              }
              return '';
            };
            const extractInline = (key) => {
              const m = body.match(new RegExp(`(^|\\r?\\n)\\s*${key}\\s*:\\s*(.+)`, 'i'));
              return m ? m[2].trim() : '';
            };

            const lower = (s) => (s || '').toLowerCase();
            let name = data.name || fromHeadings(['full name','name']) || extractInline('name');
            let role = data.role || fromHeadings(['role']) || extractInline('role');
            let affiliation = data.affiliation || fromHeadings(['affiliation']) || extractInline('affiliation');
            let image = data.image || fromHeadings(['image url','image','repo path']) || extractInline('image');
            let website = data.website || fromHeadings(['website','profile']) || extractInline('website');
            let order = data.order || fromHeadings(['order','ordering']) || extractInline('order');

            if (!name && context.payload.issue.title) {
              const mt = context.payload.issue.title.match(/Add:\s*(.+)$/i);
              if (mt) name = mt[1].trim();
            }

            const invalids = new Set(['', '_no response_', 'n/a', 'na', 'none', 'null', 'remote url (link)']);
            const sanitizeWebsite = (u) => {
              const s = (u || '').trim();
              if (invalids.has(s.toLowerCase())) return 'https://example.com';
              try { new URL(s); return s; } catch { return 'https://example.com'; }
            };
            const sanitizeImage = (img) => {
              const s = (img || '').trim();
              if (invalids.has(s.toLowerCase())) return '../../assets/vista.jpg';
              if (/^https?:/i.test(s)) return s;
              if (/^(\.\.\/){1,2}?assets\//i.test(s) || /^src\//i.test(s)) return s;
              return '../../assets/vista.jpg';
            };
            const sanitizeOrder = (_) => 999;

            website = sanitizeWebsite(website);
            image = sanitizeImage(image);
            order = String(sanitizeOrder(order));

            if (!name) {
              core.info('Missing required field: name. Skipping.');
              core.setOutput('found', 'false');
              return;
            }
            const slugify = (s) => (s || '').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
            let slug = slugify(name);
            if (!slug) { slug = 'user-' + Date.now(); }

            core.setOutput('found', 'true');
            core.setOutput('name', name);
            core.setOutput('role', role || '');
            core.setOutput('affiliation', affiliation || '');
            core.setOutput('image', image);
            core.setOutput('website', website || '');
            core.setOutput('order', order || '999');
            core.setOutput('slug', slug);

      - name: Create working branch
        if: steps.parse.outputs.found == 'true'
        run: |
          base="${{ github.event.repository.default_branch }}"
          git checkout -b add-member/${{ steps.parse.outputs.slug }} origin/$base || git checkout -b add-member/${{ steps.parse.outputs.slug }}

      - name: Ensure directories
        if: steps.parse.outputs.found == 'true'
        run: |
          mkdir -p src/content/members src/assets/members

      - name: Download image if URL
        id: dl
        if: steps.parse.outputs.found == 'true'
        run: |
          IMG="${{ steps.parse.outputs.image }}"
          if echo "$IMG" | grep -qi '^http'; then
            # Extract the path from the URL (remove query and fragment)
            path=$(echo "$IMG" | sed -E 's|^[^:/]+://[^/]+||' | cut -d'?' -f1 | cut -d'#' -f1)
            filename=$(basename "$path")
            ext="${filename##*.}"
            if [ "$filename" = "$ext" ]; then ext="jpg"; fi
            out="src/assets/members/${{ steps.parse.outputs.slug }}.$ext"
            curl -L "$IMG" -o "$out"
            echo "path=../../assets/members/$(basename "$out")" >> $GITHUB_OUTPUT
          else
            echo "path=$IMG" >> $GITHUB_OUTPUT
          fi

      - name: Check duplicate member
        id: dup
        if: steps.parse.outputs.found == 'true'
        run: |
          if [ -f "src/content/members/${{ steps.parse.outputs.slug }}.md" ]; then echo "exists=true" >> $GITHUB_OUTPUT; else echo "exists=false" >> $GITHUB_OUTPUT; fi

      - name: Stop on duplicate
        if: steps.parse.outputs.found == 'true' && steps.dup.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ℹ️ A member with slug \\`${{ steps.parse.outputs.slug }}\\` already exists. Skipping.`
            });
            core.info('Duplicate member; stopping job.');

      - name: Write member file
        if: steps.parse.outputs.found == 'true' && steps.dup.outputs.exists != 'true'
        run: |
          cat > src/content/members/${{ steps.parse.outputs.slug }}.md <<EOF
          ---
          name: "${{ steps.parse.outputs.name }}"
          role: "${{ steps.parse.outputs.role }}"
          affiliation: "${{ steps.parse.outputs.affiliation }}"
          image: "${{ steps.dl.outputs.path }}"
          website: "${{ steps.parse.outputs.website }}"
          order: ${{ steps.parse.outputs.order }}
          tags: ["member"]
          ---
          EOF

      - name: Commit changes
        if: steps.parse.outputs.found == 'true' && steps.dup.outputs.exists != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add src/content/members src/assets/members || true
          git commit -m "chore(members): add ${{ steps.parse.outputs.slug }} via issue" || echo "No changes to commit"

      - name: Push branch
        if: steps.parse.outputs.found == 'true' && steps.dup.outputs.exists != 'true'
        run: |
          git push -u origin HEAD || true

      - name: Open PR
        if: steps.parse.outputs.found == 'true' && steps.dup.outputs.exists != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const base = context.payload?.repository?.default_branch || 'main';
            const head = `add-member/${{ steps.parse.outputs.slug }}`;
            const body = `Auto-generated from issue #${{ github.event.issue.number }}.\n\n<!-- MEMBER-INFO-START -->\n\n\`\`\`yaml\nname: "${{ steps.parse.outputs.name }}"\nrole: "${{ steps.parse.outputs.role }}"\naffiliation: "${{ steps.parse.outputs.affiliation }}"\nimage: "${{ steps.dl.outputs.path }}"\nwebsite: "${{ steps.parse.outputs.website }}"\norder: ${{ steps.parse.outputs.order }}\n\`\`\`\n\n<!-- MEMBER-INFO-END -->\n\nCloses #${{ github.event.issue.number }}`;

            async function ensureLabels(labels) {
              for (const name of labels.split(',').map(s => s.trim()).filter(Boolean)) {
                try { await github.rest.issues.getLabel({ owner, repo, name }); }
                catch (e) { if (e.status === 404) await github.rest.issues.createLabel({ owner, repo, name, color: 'ededed' }); else throw e; }
              }
            }
            await ensureLabels('member, content');

            try {
              const pr = await github.rest.pulls.create({ owner, repo, base, head, title: `[Member] Add: ${{ steps.parse.outputs.name }}`, body });
              const number = pr.data.number;
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: ['member','content'] });
            } catch (e) {
              if (e.status === 422) {
                // PR likely already exists; update its body/title/labels
                const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}` });
                const existing = prs.data[0];
                if (existing) {
                  await github.rest.pulls.update({ owner, repo, pull_number: existing.number, title: `[Member] Add: ${{ steps.parse.outputs.name }}`, body });
                  await github.rest.issues.addLabels({ owner, repo, issue_number: existing.number, labels: ['member','content'] });
                } else {
                  throw e;
                }
              } else {
                throw e;
              }
            }


